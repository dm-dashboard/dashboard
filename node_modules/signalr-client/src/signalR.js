//# signalr-client
//By: [Matthew Whited](mailto:matt@whited.us?subject=signalr-client)  (c) 2014
//modifications made to add support for https/wss By: Anthony DiPierro
var url = require('url'), querystring = require('querystring'), http = require('http'), https = require('https'), WebSocketClient = require('websocket').client; // https://github.com/Worlize/WebSocket-Node
var Tools = (function () {
    function Tools() {
    }
    Tools.toCleanHubNames = function (hubNames) {
        var res = [], o = 0;
        if (hubNames.length && hubNames.length > 0) {
            for (var i = 0; i < hubNames.length; i++) {
                var p = hubNames[i];
                if (typeof p === "string") {
                    res[o++] = { name: p.toLowerCase() };
                }
            }
        }
        return res;
    };
    Tools.removeUndefinedProperties = function (obj) {
        if (obj) {
            for (var propName in obj) {
                if (typeof obj[propName] == "undefined") {
                    delete obj[propName];
                }
            }
        }
    };
    Tools.mergeFrom = function (target, source) {
        target = target || {};
        if (source) {
            for (var propName in source) {
                target[propName] = source[propName];
            }
        }
        else {
            target = {};
        }
    };
    Tools.getArgValues = function (params) {
        var res = [];
        if (params.length && params.length > 1) {
            for (var i = 1; i < params.length; i++) {
                var p = params[i];
                if (typeof p === "function" || typeof p === "undefined") {
                    p = null;
                }
                res[i - 1] = p;
            }
        }
        return res;
    };
    Tools.handlerErrors = function (errorMessage, e, errorData) {
        console.log("Error Message: " + errorMessage);
        console.log("Exception: " + e);
        console.log("Error Data: " + errorData);
        //throw errorMessage;
    };
    return Tools;
})();
var StateConnectionTypes;
(function (StateConnectionTypes) {
    StateConnectionTypes[StateConnectionTypes["unbound"] = 0] = "unbound";
    StateConnectionTypes[StateConnectionTypes["bound"] = 1] = "bound";
    StateConnectionTypes[StateConnectionTypes["connecting"] = 2] = "connecting";
    StateConnectionTypes[StateConnectionTypes["connected"] = 3] = "connected";
    StateConnectionTypes[StateConnectionTypes["disconnecting"] = 4] = "disconnecting";
    StateConnectionTypes[StateConnectionTypes["disconnected"] = 5] = "disconnected";
    StateConnectionTypes[StateConnectionTypes["connectFailed"] = 6] = "connectFailed";
    StateConnectionTypes[StateConnectionTypes["errorOccured"] = 7] = "errorOccured";
    StateConnectionTypes[StateConnectionTypes["retryingConnection"] = 8] = "retryingConnection";
    StateConnectionTypes[StateConnectionTypes["bindingError"] = 9] = "bindingError";
})(StateConnectionTypes || (StateConnectionTypes = {}));
;
var StateConnection = (function () {
    function StateConnection() {
        this._state = 0 /* unbound */;
    }
    Object.defineProperty(StateConnection.prototype, "State", {
        get: function () {
            return this._state;
        },
        set: function (value) {
            this._state = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateConnection.prototype, "Token", {
        get: function () {
            return this._token;
        },
        set: function (value) {
            this._token = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateConnection.prototype, "ID", {
        get: function () {
            return this._id;
        },
        set: function (value) {
            this._id = value;
        },
        enumerable: true,
        configurable: true
    });
    return StateConnection;
})();
var ProxySettings = (function () {
    function ProxySettings() {
    }
    Object.defineProperty(ProxySettings.prototype, "Host", {
        get: function () {
            return this._host;
        },
        set: function (value) {
            this._host = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ProxySettings.prototype, "Port", {
        get: function () {
            return this._port;
        },
        set: function (value) {
            this._port = value;
        },
        enumerable: true,
        configurable: true
    });
    return ProxySettings;
})();
var ConnectionTimeoutSettings = (function () {
    function ConnectionTimeoutSettings() {
    }
    Object.defineProperty(ConnectionTimeoutSettings.prototype, "KeepAlive", {
        get: function () {
            return this._keepAlive;
        },
        set: function (value) {
            this._keepAlive = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConnectionTimeoutSettings.prototype, "Disconnect", {
        get: function () {
            return this._disconnect;
        },
        set: function (value) {
            this._disconnect = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConnectionTimeoutSettings.prototype, "Connect", {
        get: function () {
            return this._connect;
        },
        set: function (value) {
            this._connect = value;
        },
        enumerable: true,
        configurable: true
    });
    return ConnectionTimeoutSettings;
})();
var RetryCheck = (function () {
    function RetryCheck(inital, count) {
        this.inital = inital;
        this.count = count;
    }
    return RetryCheck;
})();
var ServiceHandlers = (function () {
    function ServiceHandlers() {
        this.bound = undefined;
        this.connectFailed = undefined;
        this.connected = undefined;
        this.reconnected = undefined;
        this.disconnected = undefined;
        this.onerror = undefined;
        this.messageReceived = undefined;
        this.bindingError = undefined;
        this.onUnauthorized = undefined;
        this.reconnecting = undefined;
    }
    ServiceHandlers.prototype.bound = function () {
    };
    ServiceHandlers.prototype.connectFailed = function (error) {
    };
    ServiceHandlers.prototype.connected = function (connection) {
    };
    ServiceHandlers.prototype.reconnected = function (connection) {
    };
    ServiceHandlers.prototype.disconnected = function () {
    };
    ServiceHandlers.prototype.onerror = function (error) {
    };
    ServiceHandlers.prototype.messageReceived = function (message) {
        return false;
    };
    ServiceHandlers.prototype.bindingError = function (error) {
    };
    ServiceHandlers.prototype.onUnauthorized = function (result) {
    };
    ServiceHandlers.prototype.reconnecting = function (retry) {
        return false;
    };
    return ServiceHandlers;
})();
var InternalClient = (function () {
    function InternalClient(baseUrl, hubNames, reconnectTimeout, doNotStart, client) {
        this._bound = false;
        this._proxy = new ProxySettings();
        this._headers = {};
        this._queryString = {};
        this._connection = new StateConnection();
        this._timeouts = new ConnectionTimeoutSettings();
        this._hubs = [];
        this._hubNames = [];
        this._hubData = [];
        this._handlers = {};
        this._serviceHandlers = new ServiceHandlers();
        this.BaseUrl = baseUrl;
        this.HubNames = hubNames;
        this.Client = client;
        this.Websocket = new InternalWebsocketConnection(reconnectTimeout);
        this.bindWebsocketEvents();
        //if (doNotStart) {
        //}
        //else {
        //    this.start(true);
        //}
    }
    Object.defineProperty(InternalClient.prototype, "Proxy", {
        get: function () {
            return this._proxy;
        },
        set: function (value) {
            this._proxy = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InternalClient.prototype, "Headers", {
        get: function () {
            return this._headers;
        },
        set: function (value) {
            this._headers = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InternalClient.prototype, "QueryString", {
        get: function () {
            return this._queryString;
        },
        set: function (value) {
            this._queryString = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InternalClient.prototype, "Client", {
        get: function () {
            return this._client;
        },
        set: function (value) {
            this._client = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InternalClient.prototype, "BaseUrl", {
        get: function () {
            return this._baseUrl;
        },
        set: function (value) {
            this._baseUrl = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InternalClient.prototype, "Connection", {
        get: function () {
            return this._connection;
        },
        set: function (value) {
            this._connection = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InternalClient.prototype, "Timeouts", {
        get: function () {
            return this._timeouts;
        },
        set: function (value) {
            this._timeouts = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InternalClient.prototype, "Hubs", {
        get: function () {
            return this._hubs;
        },
        set: function (value) {
            this._hubs = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InternalClient.prototype, "HubNames", {
        get: function () {
            return this._hubNames;
        },
        set: function (value) {
            this._hubNames = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InternalClient.prototype, "HubData", {
        get: function () {
            return this._hubData;
        },
        set: function (value) {
            this._hubData = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InternalClient.prototype, "Handlers", {
        get: function () {
            return this._handlers;
        },
        set: function (value) {
            this._handlers = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InternalClient.prototype, "ServiceHandlers", {
        get: function () {
            return this._serviceHandlers;
        },
        set: function (value) {
            this._serviceHandlers = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InternalClient.prototype, "Websocket", {
        get: function () {
            return this._websocket;
        },
        set: function (value) {
            this._websocket = value;
        },
        enumerable: true,
        configurable: true
    });
    InternalClient.prototype.invoke = function (hub, methodName, args) {
        this.start(false);
        var payload = InternalClient.buildPayload(hub.name, methodName, args, this.Websocket.MessageID++);
        //try to send message to signalR host
        this.Websocket.sendPayload(payload);
        return payload;
    };
    InternalClient.prototype.scheduleReconnection = function (isInitalRetry) {
        var _this = this;
        //Ensure state is still reconnecting
        if (this.Connection.State == 8 /* retryingConnection */) {
            if (isInitalRetry) {
                this.Websocket.ReconnectCount = 0;
            }
            else {
                this.Websocket.ReconnectCount++;
            }
            var cancelRetry;
            if (this.ServiceHandlers.reconnecting) {
                var retry = new RetryCheck(isInitalRetry, this.Websocket.ReconnectCount);
                cancelRetry = this.ServiceHandlers.reconnecting.apply(this.Client, [retry]);
            }
            if (!cancelRetry) {
                setTimeout(function () {
                    var connectQueryString = InternalClient.getConnectQueryString(_this);
                    _this.Websocket.Client.connect(connectQueryString, undefined, undefined, _this.Headers);
                }, 1000 + this.Websocket.ReconnectTimeout);
                return true;
            }
        }
        return false;
    };
    InternalClient.prototype.start = function (tryOnceAgain) {
        if (!this._bound)
            this.getBinding();
        //connected: 3,
        //retryingConnection: 8,
        //connecting: 2,
        if (this.Connection.State == 3 /* connected */ || this.Connection.State == 8 /* retryingConnection */ || this.Connection.State == 2 /* connecting */) {
            return true;
        }
        else if (this.Connection.State == 9 /* bindingError */ || this.Connection.State == 0 /* unbound */) {
            if (!tryOnceAgain) {
                this.getBinding();
                setImmediate(this.start, true);
            }
            return false;
        }
        else if (this.Connection.State == 1 /* bound */ || this.Connection.State == 4 /* disconnecting */ || this.Connection.State == 5 /* disconnected */ || this.Connection.State == 6 /* connectFailed */ || this.Connection.State == 7 /* errorOccured */) {
            this.Connection.State = 2 /* connecting */;
            //connect to websockets
            var connectQueryString = InternalClient.getConnectQueryString(this);
            this.Websocket.Client.connect(connectQueryString, undefined, undefined, this.Headers);
            return false;
        }
        return true;
    };
    InternalClient.prototype.getBinding = function () {
        var _this = this;
        InternalClient.getBindings(this.BaseUrl, this.HubNames, function (bindings) {
            _this.HubData = bindings.hubs;
            for (var i = 0; i < bindings.hubs.length; i++) {
                var hubData = bindings.hubs[i];
                _this.Hubs[hubData.name] = new Hub(_this, hubData);
            }
            //timeouts: { keepAlive: disconnect: connect: },
            _this.Timeouts.KeepAlive = bindings.timeouts.keepAlive;
            _this.Timeouts.Disconnect = bindings.timeouts.disconnect;
            _this.Timeouts.Connect = bindings.timeouts.connect;
            //connection: { token: id: },
            _this.Connection.State = 1 /* bound */;
            _this.Connection.ID = bindings.connection.id;
            _this.Connection.Token = bindings.connection.token;
            _this.start(true);
            if (_this.ServiceHandlers.bound) {
                _this.ServiceHandlers.bound.apply(_this.Client);
            }
            _this._bound = true;
        }, Tools.handlerErrors, _this);
    };
    InternalClient.prototype.bindWebsocketEvents = function () {
        var _this = this;
        this.Websocket.Client.on('connectFailed', function (error) {
            if (_this.Connection.State == 8 /* retryingConnection */ && _this.scheduleReconnection(false)) {
            }
            else {
                _this.Connection.State = 6 /* connectFailed */;
                if (_this.ServiceHandlers.connectFailed) {
                    _this.ServiceHandlers.connectFailed.apply(_this.Client, [error]);
                }
            }
        });
        this.Websocket.Client.on('connect', function (connection) {
            _this.Websocket.Connection = connection;
            _this.Websocket.MessageID = 0; //Reset MessageID on new connection
            //Note: check for reconnecting
            if (8 /* retryingConnection */) {
                //Note: reconnected event  
                if (_this.ServiceHandlers.reconnected) {
                    _this.ServiceHandlers.reconnected.apply(_this.Client, [connection]);
                }
                else {
                    console.log("Reconnected!");
                }
            }
            else {
                if (_this.ServiceHandlers.connected) {
                    _this.ServiceHandlers.connected.apply(_this.Client, [connection]);
                }
                else {
                    console.log("Connected!");
                }
            }
            connection.on('error', function (error) {
                this.websocket.connection = undefined;
                this.Connection.State = 7 /* errorOccured */;
                //Note: Add support for automatic retry
                if (error.code == "ECONNRESET") {
                    this.Connection.State = 8 /* retryingConnection */;
                    if (this.serviceHandlers.connectionLost) {
                        this.serviceHandlers.connectionLost.apply(this.Client, [error]);
                    }
                    else {
                        console.log("Scheduled Reconnection: " + error.toString());
                    }
                    this.scheduleReconnection(true);
                }
                else {
                    if (this.serviceHandlers.onerror) {
                        this.serviceHandlers.onerror.apply(this.Client, [error]);
                    }
                    else {
                        console.log("Connection Error: " + error.toString());
                    }
                }
            });
            connection.on('close', function () {
                _this.Websocket.Connection = undefined; //Release connection on close
                if (_this.Connection.State != 8 /* retryingConnection */) {
                    _this.Connection.State = 5 /* disconnected */;
                }
                if (_this.ServiceHandlers.disconnected) {
                    _this.ServiceHandlers.disconnected.apply(_this.Client);
                }
            });
            connection.on('message', function (message) {
                var handled = false;
                if (_this.ServiceHandlers.messageReceived) {
                    handled = _this.ServiceHandlers.messageReceived.apply(_this.Client, [message]);
                }
                if (!handled) {
                    //{"C":"d-8F1AB453-B,0|C,0|D,1|E,0","S":1,"M":[]}
                    if (message.type === 'utf8' && message.utf8Data != "{}") {
                        var parsed = JSON.parse(message.utf8Data);
                        //{"C":"d-74C09D5E-B,1|C,0|D,1|E,0","M":[{"H":"TestHub","M":"addMessage","A":["ie","sgds"]}]}
                        if (parsed.M) {
                            for (var i = 0; i < parsed.M.length; i++) {
                                var mesg = parsed.M[i];
                                var hubName = mesg.H.toLowerCase();
                                var handler = _this.Handlers[hubName];
                                if (handler) {
                                    var methodName = mesg.M.toLowerCase();
                                    var method = handler[methodName];
                                    if (method) {
                                        var hub = _this.Client.hub(hubName);
                                        method.apply(hub, mesg.A);
                                    }
                                }
                            }
                        }
                    }
                }
            });
        });
    };
    InternalClient.negotiateProxies = function (baseUrl, hubNames, onSuccess, onError, _client) {
        var cleanedHubs = Tools.toCleanHubNames(hubNames);
        if (!cleanedHubs || cleanedHubs.length < 1) {
            onError('you must define at least one hub name and they must be typeof string');
            return;
        }
        var negotiateData = "";
        var negotiateUrl = baseUrl + "/negotiate?" + querystring.stringify({
            connectionData: JSON.stringify(cleanedHubs),
            clientProtocol: 1.3
        });
        var negotiateUrlOptions = url.parse(negotiateUrl, true);
        var negotiateFunction = function (res) {
            res.on('data', function (chunk) {
                negotiateData += chunk;
            });
            res.on('end', function (endRes) {
                try {
                    if (res.statusCode == 200) {
                        var negotiateObj = JSON.parse(negotiateData);
                        negotiateObj.Hubs = cleanedHubs;
                        onSuccess(negotiateObj);
                    }
                    else if (res.statusCode == 401 || res.statusCode == 302) {
                        if (_client.ServiceHandlers.onUnauthorized) {
                            _client.ServiceHandlers.onUnauthorized.apply(_client.Client, [res]);
                        }
                        else {
                            console.log('negotiate::Unauthorized (' + res.statusCode + ')');
                        }
                    }
                    else {
                        console.log('negotiate::unknown (' + res.statusCode + ')');
                    }
                }
                catch (e) {
                    onError('Parse Error', e, negotiateData);
                }
            });
            res.on('error', function (e) {
                _client.Connection.State = 9 /* bindingError */;
                if (_client.ServiceHandlers.bindingError) {
                    _client.ServiceHandlers.bindingError.apply(_client.Client, [e]);
                }
                else {
                    onError('HTTP Error', e);
                }
            });
        };
        var negotiateErrorFunction = function (e) {
            _client.Connection.State = 9 /* bindingError */;
            if (_client.ServiceHandlers.bindingError) {
                _client.ServiceHandlers.bindingError.apply(_client.Client, [e]);
            }
            else {
                onError('HTTP Negotiate Error', e);
            }
        };
        if (negotiateUrlOptions.headers === undefined) {
            negotiateUrlOptions.headers = {};
        }
        Tools.mergeFrom(negotiateUrlOptions.headers, _client.Headers || {});
        if (_client.Proxy && _client.Proxy.Host && _client.Proxy.Port) {
            negotiateUrlOptions.path = negotiateUrlOptions.protocol + '//' + negotiateUrlOptions.host + negotiateUrlOptions.path;
            negotiateUrlOptions.headers.host = negotiateUrlOptions.host;
            negotiateUrlOptions.host = _client.Proxy.Host;
            negotiateUrlOptions.port = _client.Proxy.Port;
        }
        if (negotiateUrlOptions.protocol === 'http:') {
            var negotiateResult = http.get(negotiateUrlOptions, negotiateFunction).on('error', negotiateErrorFunction);
        }
        else if (negotiateUrlOptions.protocol === 'wss:') {
            negotiateUrlOptions.protocol = 'https:';
            var negotiateResult = https.get(negotiateUrlOptions, negotiateFunction).on('error', negotiateErrorFunction);
        }
        else {
            onError('Protocol Error');
        }
    };
    InternalClient.getBindings = function (baseUrl, hubNames, onSuccess, onError, _client) {
        InternalClient.negotiateProxies(baseUrl, hubNames, function (negotiatedOptions) {
            if (!negotiatedOptions.TryWebSockets) {
                onError('This client only supports websockets', undefined, negotiatedOptions);
                return;
            }
            onSuccess({
                url: baseUrl,
                connection: {
                    token: negotiatedOptions.ConnectionToken,
                    id: negotiatedOptions.ConnectionId
                },
                timeouts: {
                    keepAlive: negotiatedOptions.KeepAliveTimeout,
                    disconnect: negotiatedOptions.DisconnectTimeout,
                    connect: negotiatedOptions.TransportConnectTimeout
                },
                hubs: negotiatedOptions.Hubs
            });
        }, onError, _client);
    };
    InternalClient.getConnectQueryString = function (_client) {
        var connectData = "";
        var qs = {
            transport: "webSockets",
            connectionToken: _client.Connection.Token,
            connectionData: JSON.stringify(_client.HubData),
            tid: 10
        };
        Tools.mergeFrom(qs, _client.QueryString || {});
        var connectQueryString = _client.BaseUrl + "/connect?" + querystring.stringify(qs);
        return connectQueryString;
    };
    InternalClient.buildPayload = function (hubName, methodName, args, messageId) {
        var data = {
            H: hubName,
            M: methodName,
            A: args,
            I: messageId
        };
        var payload = JSON.stringify(data);
        return payload;
    };
    return InternalClient;
})();
var IBindingResults = (function () {
    function IBindingResults() {
    }
    return IBindingResults;
})();
var PublicClient = (function () {
    function PublicClient(baseUrl, hubs, reconnectTimeout, doNotStart) {
        this._client = new InternalClient(baseUrl, hubs, reconnectTimeout, doNotStart, this);
    }
    Object.defineProperty(PublicClient.prototype, "url", {
        get: function () {
            return this._client.BaseUrl;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PublicClient.prototype, "state", {
        get: function () {
            return {
                code: this._client.Connection.State,
                desc: this._client.Connection.State.toString()
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PublicClient.prototype, "proxy", {
        get: function () {
            return this._client.Proxy;
        },
        set: function (value) {
            Tools.mergeFrom(this._client.Proxy, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PublicClient.prototype, "headers", {
        get: function () {
            return this._client.Headers;
        },
        set: function (value) {
            Tools.mergeFrom(this._client.Headers, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PublicClient.prototype, "queryString", {
        get: function () {
            return this._client.QueryString;
        },
        set: function (value) {
            Tools.mergeFrom(this._client.QueryString, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PublicClient.prototype, "handlers", {
        get: function () {
            return this._client.Handlers;
        },
        set: function (value) {
            Tools.mergeFrom(this._client.Handlers, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PublicClient.prototype, "serviceHandlers", {
        get: function () {
            return this._client.ServiceHandlers;
        },
        set: function (value) {
            Tools.mergeFrom(this._client.ServiceHandlers, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PublicClient.prototype, "hubs", {
        get: function () {
            var ret = [], x = 0;
            for (var h in this._client.Hubs) {
                ret[x++] = h.name;
            }
            return ret;
        },
        enumerable: true,
        configurable: true
    });
    PublicClient.prototype.hub = function (hubName) {
        this._client.start(false);
        return this._client.Hubs[hubName.toLowerCase()];
    };
    PublicClient.prototype.on = function (hubName, methodName, callback) {
        var handler = this._client.Handlers[hubName.toLowerCase()];
        if (!handler) {
            handler = this._client.Handlers[hubName.toLowerCase()] = {};
        }
        var method = handler[methodName.toLowerCase()] = callback;
    };
    PublicClient.prototype.invoke = function (hubName, methodName) {
        var hub = this.hub(hubName);
        if (!hub)
            return;
        var args = Tools.getArgValues(arguments);
        return hub.invoke.apply(hub, args);
    };
    PublicClient.prototype.end = function () {
        if ((this._client.Connection.State == 2 /* connecting */ || this._client.Connection.State == 3 /* connected */) && this._client.Websocket.Connection) {
            this._client.Connection.State = 4 /* disconnecting */;
            var connection = this._client.Websocket.Connection;
            this._client.Websocket.Connection = undefined;
            connection.close();
        }
    };
    PublicClient.prototype.start = function () {
        this._client.start(true);
    };
    return PublicClient;
})();
var Hub = (function () {
    function Hub(client, hubData) {
        this._data = hubData;
        this._client = client;
    }
    Object.defineProperty(Hub.prototype, "name", {
        get: function () {
            return this._data.name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hub.prototype, "client", {
        get: function () {
            return this._client.Client;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hub.prototype, "lastMessageId", {
        //get handlers() { return this._client.Handlers; }
        get: function () {
            return this._client.Websocket.MessageID;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hub.prototype, "headers", {
        get: function () {
            Tools.removeUndefinedProperties(this._client.Headers);
            return this._client.Headers;
        },
        set: function (value) {
            Tools.mergeFrom(this._client.Headers, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hub.prototype, "proxy", {
        get: function () {
            Tools.removeUndefinedProperties(this._client.Proxy);
            return this._client.Proxy;
        },
        set: function (value) {
            Tools.mergeFrom(this._client.Proxy, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hub.prototype, "queryString", {
        get: function () {
            Tools.removeUndefinedProperties(this._client.QueryString);
            return this._client.QueryString;
        },
        set: function (value) {
            Tools.mergeFrom(this._client.QueryString, value);
        },
        enumerable: true,
        configurable: true
    });
    Hub.prototype.invoke = function (methodName) {
        var args = Tools.getArgValues(arguments);
        return this._client.invoke(this, methodName, args);
    };
    Hub.prototype.on = function (methodName, callback) {
        this.client.on(this.name, methodName, callback);
    };
    return Hub;
})();
var InternalWebsocketConnection = (function () {
    function InternalWebsocketConnection(reconnectTimeout) {
        // https://github.com/Worlize/WebSocket-Node
        this._client = new WebSocketClient();
        this._messageid = 0;
        this._reconnectTimeout = 10;
        this._reconnectCount = 10;
        this.ReconnectTimeout = reconnectTimeout || 10;
    }
    Object.defineProperty(InternalWebsocketConnection.prototype, "Client", {
        get: function () {
            return this._client;
        },
        set: function (value) {
            this._client = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InternalWebsocketConnection.prototype, "Connection", {
        get: function () {
            return this._connection;
        },
        set: function (value) {
            this._connection = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InternalWebsocketConnection.prototype, "MessageID", {
        get: function () {
            return this._messageid;
        },
        set: function (value) {
            this._messageid = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InternalWebsocketConnection.prototype, "ReconnectTimeout", {
        get: function () {
            return this._reconnectTimeout;
        },
        set: function (value) {
            this._reconnectTimeout = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InternalWebsocketConnection.prototype, "ReconnectCount", {
        get: function () {
            return this._reconnectCount;
        },
        set: function (value) {
            this._reconnectCount = value;
        },
        enumerable: true,
        configurable: true
    });
    InternalWebsocketConnection.prototype.sendPayload = function (payload) {
        if (this.Connection) {
            this.Connection.send(payload);
        }
        else {
            setImmediate(this.sendPayload, payload);
        }
    };
    return InternalWebsocketConnection;
})();
//function clientInterface(baseUrl: string, hubs: Array<string>, reconnectTimeout: number, doNotStart: boolean) {
//    return new PublicClient(baseUrl, hubs, reconnectTimeout, doNotStart);
//}
module.exports = {
    client: PublicClient
};
//# sourceMappingURL=signalR.js.map